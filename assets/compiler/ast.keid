namespace keidc::ast

import (
    core::collections
    core::object
    core::string
    keidc::common
    keidc::ksdl
    keidc::registry
    keidc::types
)

public struct AstToken<T> {
    node: T
    loc: TokenLocation
}

implement <T: ToString> ToString for AstToken<T> {
    toString(): string => string.format(this.node.toString(), " @ ", this.loc.toString())
}

public class AstGenericDecl {
    name: AstToken<string>
}

public class AstClassField {
    modifiers: List<AstToken<Modifier>>
    name: AstToken<string>
    type: AstToken<ComplexType>
    initialValue: ?AstToken<AstExpr>
}

implement ToString for AstClassField {
    toString(): string {
        let sb = StringBuilder.empty()
        sb.append(this.name.node)
        sb.append(": ")
        sb.append(this.type.node.toString())
        return sb.toString()
    }
}

public class AstFunctionParam {
    name: AstToken<string>
    type: AstToken<ComplexType>
}

public enum VarargsMode {
    None
    Native
    Array {
        param: AstFunctionParam
    }
}

public class AstFunction {
    modifiers: List<AstToken<Modifier>>
    name: AstToken<string>
    generics: ?List<AstGenericDecl>
    params: List<AstFunctionParam>
    returnType: ?AstToken<ComplexType>
    varargs: VarargsMode
    body: ?List<AstToken<AstStatement>>
}

implement ToString for AstFunction {
    toString(): string {
        let sb = StringBuilder.empty()
        sb.append(this.name.node)
        sb.append("(")
        for param in this.params {
            sb.append(param.name.node)
            sb.append(": ")
            sb.append(param.type.node.toString())
            sb.append(", ")
        }
        sb.append(")")
        if this.returnType != null {
            sb.append(": ")
            sb.append(this.returnType!.node.toString())
        }
        return sb.toString()
    }
}

implement Resolvable for AstFunction {
    resolve(trc: TypeResolveContext) {
        for param in this.params {
            param.type = trc.resolve(param.type)
        }
        if this.returnType != null {
            this.returnType = trc.resolve(this.returnType!)
        }
    }
}

public class AstImplement {
    generics: ?List<AstGenericDecl>
    interface: AstToken<string>
    interfaceGenerics: ?List<AstToken<ComplexType>>
    target: AstToken<string>
    targetGenerics: ?List<AstToken<ComplexType>>
    methods: List<AstFunction>
}

implement ToString for AstImplement {
    toString(): string {
        return string.format("AstImplement(", this.interface.node, " for ", this.target.node, ")")
    }
}

implement Resolvable for AstImplement {
    resolve(trc: TypeResolveContext) {
        this.interface = trc.resolveTypeName(this.interface)
        this.target = trc.resolveTypeName(this.target)
        if this.interfaceGenerics != null {
            for i in range.create(this.interfaceGenerics!.length) {
                let interfaceGeneric = this.interfaceGenerics!.get(i)
                this.interfaceGenerics!.set(i, trc.resolve(interfaceGeneric))
            }
        }
        if this.targetGenerics != null {
            for i in range.create(this.targetGenerics!.length) {
                let targetGeneric = this.targetGenerics!.get(i)
                this.targetGenerics!.set(i, trc.resolve(targetGeneric))
            }
        }
        for method in this.methods {
            method.resolve(trc)
        }
    }
}

public enum LetKind {
    Mutable
    Constant
}

public class AstLet {
    kind: LetKind
    name: AstToken<string>
    valueType: ?AstToken<ComplexType>
    initialValue: ?AstToken<AstExpr>
}

implement Resolvable for AstLet {
    resolve(trc: TypeResolveContext) {
        this.name.node = string.format(trc.namespace, ".", this.name.node)
        if this.valueType != null {
            this.valueType!.node = trc.resolve(this.valueType!.node)
        }
    }
}

public class AstAssign {
    deref: bool
    lhs: AstToken<AstExpr>
    op: AstToken<AstOperator>
    rhs: AstToken<AstExpr>
}

public class AstClass {
    kind: AstToken<ObjectKind>
    modifiers: List<AstToken<Modifier>>
    name: AstToken<string>
    generics: ?List<AstGenericDecl>
    superclass: ?AstToken<string>
    superclassGenerics: ?List<AstToken<ComplexType>>
    constructor: ?List<AstToken<AstStatement>>
    destructor: ?List<AstToken<AstStatement>>
    fields: List<AstClassField>
    methods: List<AstFunction>
}

implement Resolvable for AstClass {
    resolve(trc: TypeResolveContext) {
        this.name.node = string.format(trc.namespace, ".", this.name.node)
        if this.superclass != null {
            this.superclass = trc.resolveTypeName(this.superclass!)
        }
        if this.superclassGenerics != null {
            for i in range.create(this.superclassGenerics!.length) {
                let superclassGeneric = this.superclassGenerics!.get(i)
                this.superclassGenerics!.set(i, trc.resolve(superclassGeneric))
            }
        }
        for field in this.fields {
            field.type = trc.resolve(field.type)
        }
        for method in this.methods {
            method.resolve(trc)
        }
    }
}

public class AnonymousTypeField {
    name: AstToken<string>
    type: AstToken<ComplexType>
}

public class AstEnumVariant {
    name: AstToken<string>
    data: ?List<AnonymousTypeField>
}

public class AstEnum extends AstClass {
    variants: List<AstEnumVariant>
}

implement Resolvable for AstEnum {
    resolve(trc: TypeResolveContext) {
        super.resolve(trc)

        for variant in this.variants {
            variant.resolve(trc)
        }
    }
}

implement ToString for AstClass {
    toString(): string {
        let sb = StringBuilder.empty()
        sb.append("AstClass(kind=")
        sb.append(this.kind.node.toString())
        sb.append(", name=")
        sb.append(this.name.node)
        sb.append(", superclass=")
        if this.superclass == null {
            sb.append("null")
        } else {
            sb.append(this.superclass!.node.toString())
        }
        sb.append(", modifiers=")
        for modifier in this.modifiers {
            sb.append(modifier.node.toString())
            sb.append(" ")
        }
        sb.append(", fields=[")
        for field in this.fields {
            sb.append(field.toString())
            sb.append(", ")
        }
        sb.append("])")
        return sb.toString()
    }
}

public struct AstIfBlock {
    condition: AstToken<AstExpr>
    block: List<AstToken<AstStatement>>
}

public enum AstStatement {
    Return {
        operand: ?AstToken<AstExpr>
    }
    Expr {
        value: AstToken<AstExpr>
    }
    UnsafeBlock {
        statements: List<AstToken<AstStatement>>
    }
    Let {
        statement: AstLet
    }
    Assign {
        statement: AstAssign
    }
    Throw {
        error: AstToken<AstExpr>
    }
    IfChain {
        conditionals: List<AstIfBlock>
        fallback: ?List<AstToken<AstStatement>>
    }
}

public enum AstOperator {
    Assign
    Equals
    NotEquals
    Add
    Subtract
    Multiply
    Divide
    Modulus
    LeftShift
    RightShift
    BooleanOr
    BooleanAnd
    LessThanOrEquals
    GreaterThanOrEquals
    LessThan
    GreaterThan
    As
    Not
    NonNullAssertion
    Spread
    NullCoalesce
    MemberAccess
}

implement ToString for AstOperator {
    toString(): string => match this {
        Assign => "="
        Equals => "=="
        NotEquals => "!="
        Add => "+"
        Subtract => "-"
        Multiply => "*"
        Divide => "/"
        Modulus => "%"
        LeftShift => "<<"
        RightShift => ">>"
        BooleanOr => "or"
        BooleanAnd => "and"
        LessThanOrEquals => "<="
        GreaterThanOrEquals => ">="
        LessThan => "<"
        GreaterThan => ">"
        As => "as"
        Not => "not"
        NonNullAssertion => "!"
        Spread => "..."
        NullCoalesce => "??"
        MemberAccess => "."
        _ => "unknown"
    }
}

public class AstField {
    name: AstToken<string>
    value: ?AstToken<AstExpr>
}

public enum AstExpr {
    NullLit
    BoolLit {
        value: bool
    }
    StringLit {
        value: string
    }
    CharLit {
        value: char
    }
    UnsignedIntLit {
        value: uint64
    }
    SignedIntLit {
        value: int64
    }
    Ident {
        value: string
    }
    Unary {
        operator: AstToken<AstOperator>
        operand: Box<AstToken<AstExpr>>
    }
    Binary {
        lhs: Box<AstToken<AstExpr>>
        operator: AstToken<AstOperator>
        rhs: Box<AstToken<AstExpr>>
    }
    NewSlice {
        type: AstToken<ComplexType>
        initialValue: Box<AstToken<AstExpr>>
        length: Box<AstToken<AstExpr>>
    }
    NewArray {
        type: AstToken<ComplexType>
        initialValue: Box<AstToken<AstExpr>>
        length: ?Box<AstToken<AstExpr>>
    }
    ConstSlice {
        type: AstToken<ComplexType>
        elements: List<AstToken<AstExpr>>
    }
    FuncCall {
        callee: Box<AstToken<AstExpr>>
        generics: ?List<AstToken<ComplexType>>
        params: List<AstToken<AstExpr>>
    }
    NewObject {
        type: AstToken<ComplexType>
        fields: List<AstField>
    }
}

public class AstKeidProgram {
    source: string
    namespace: AstToken<string>
    imports: List<AstToken<string>>
    classes: List<AstClass>
    impls: List<AstImplement>
    functions: List<AstFunction>
    globals: List<AstLet>
}

implement ToString for AstKeidProgram {
    toString(): string {
        let sb = StringBuilder.empty()
        sb.append("AstKeidProgram(namespace=")
        sb.append(this.namespace.node)
        sb.append(", imports=[")
        for import in this.imports {
            sb.append(import.node)
            sb.append(", ")
        }
        sb.append("], classes=[\n")
        for class in this.classes {
            sb.append("  ")
            sb.append(class.toString())
            sb.append(",\n")
        }
        sb.append("], impls=[\n")
        for impl in this.impls {
            sb.append("  ")
            sb.append(impl.toString())
            sb.append(",\n")
        }
        sb.append("], functions=[\n")
        for func in this.functions {
            sb.append("  ")
            sb.append(func.toString())
            sb.append(",\n")
        }
        sb.append("])")
        return sb.toString()
    }
}
