namespace keidc::parser

import (
    core::collections
    core::error
    keidc::ast
    keidc::ksdl
    std::fs
)

class KeidParser {
    source: string

    parseString(match: RuleMatch): AstToken<string> {
        return new AstToken<string> {
            node = match.token.getText(this.source)
            loc = match.token
        }
    }

    parseGenericDecls(match: RuleMatch): List<AstGenericDecl> {
        let decls = List.empty<AstGenericDecl>()
        for decl in match.getGroup("decls") {
            let declName = decl.getGroupValue("name")
            decls.push(new AstGenericDecl {
                name = this.parseString(declName)
            })
        }
        return decls
    }

    parseModifers(modifiers: List<AstToken<KeidModifier>>, astModifiers: List<RuleMatch>) {
        for astModifier in astModifiers {
            let text = astModifier.token.getText(this.source)
            let modifier = match text {
                "public" => KeidModifier.Public
                "extern" => KeidModifier.Extern
                "static" => KeidModifier.Static
                // TODO: fix this not compiling _ => throw Error.create("ParseError: invalid modifier: " + text)
            }
            modifiers.push(new AstToken<KeidModifier> {
                node = modifier
                loc = astModifier.token
            })
        }
    }

    parseClass(match: RuleMatch): AstClass {
        let modifiers = List.empty<AstToken<KeidModifier>>()
        if match.hasGroup("modifiers") {
            this.parseModifers(modifiers, match.getGroup("modifiers"))
        }

        let name = this.parseString(match.getGroupValue("name"))
        let generics: ?List<AstGenericDecl> = null
        if match.hasGroup("generics") {
            generics = this.parseGenericDecls(match.getGroupValue("generics"))
        }

        return new AstClass {
            modifiers
            name
            generics
        }
    }

    parseProgram(match: RuleMatch): AstKeidProgram {
        let namespaceMatch = match.getGroupValue("namespace").getGroupValue("namespace")
        let namespace = this.parseString(namespaceMatch)
        let imports = List.empty<AstToken<string>>()
        let classes = List.empty<AstClass>()

        for statementMatch in match.getGroup("statements") {
            let statement = statementMatch.getGroupValue("st")
            if statement.rule == "ImportStatement" {
                let modules = statement.getGroup("modules")
                for module in modules {
                    imports.push(this.parseString(module))
                }
            } else if statement.rule == "ClassDecl" {
                classes.push(this.parseClass(statement))
            }
        }

        return new AstKeidProgram {
            namespace
            imports
            classes
        }
    }
}

public function parseKeidSource(programText: string): AstKeidProgram {
    let syntaxDefFile = File.open("../keid/assets/compiler/syntax.def", FileOpenMode.ReadOnly)
    let syntaxDef = string.fromUtf8(syntaxDefFile.readAllBytes())
    syntaxDefFile.close()

    let parser = KsdlParser.fromKsdl(syntaxDef)
    let programRule = parser.getRule("Program")
    let parseResult = programRule.parse(programText)
    match parseResult {
        Success { match, } => {
            std::io.println(match.toString())

            let keidParser = new KeidParser {
                source = programText
            }
            return keidParser.parseProgram(match)
        }
        _ => {}
    }

    throw Error.create("Parse failure!")
}
