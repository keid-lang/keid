namespace keidc::parser

import (
    core::collections
    core::error
    core::object
    keidc::ast
    keidc::ksdl
    std::fs
)

function tokenize<T>(match: RuleMatch, node: T): AstToken<T> {
    return new AstToken<T> {
        node
        loc = match.token
    }
}

class KeidParser {
    source: string

    parseString(match: RuleMatch): AstToken<string> {
        return tokenize<string>(match, match.token.getText(this.source))
    }

    parseGenericDecls(match: RuleMatch): List<AstGenericDecl> {
        let decls = List.empty<AstGenericDecl>()
        for decl in match.getGroup("decls") {
            let declName = decl.getGroupValue("name")
            decls.push(new AstGenericDecl {
                name = this.parseString(declName)
            })
        }
        return decls
    }

    parseModifers(modifiers: List<AstToken<KeidModifier>>, astModifiers: List<RuleMatch>) {
        for astModifier in astModifiers {
            let text = astModifier.token.getText(this.source)
            let modifier = match text {
                "public" => KeidModifier.Public
                "extern" => KeidModifier.Extern
                "static" => KeidModifier.Static
                // TODO: fix this not compiling _ => throw Error.create("ParseError: invalid modifier: " + text)
            }
            modifiers.push(new AstToken<KeidModifier> {
                node = modifier
                loc = astModifier.token
            })
        }
    }

    parseClass(match: RuleMatch): AstClass {
        let modifiers = List.empty<AstToken<KeidModifier>>()
        if match.hasGroup("modifiers") {
            this.parseModifers(modifiers, match.getGroup("modifiers"))
        }

        let typeMatch = match.getGroupValue("type")
        let typeText = typeMatch.token.getText(this.source)
        let type = tokenize<AstClassType>(typeMatch, match typeText {
            "class" => AstClassType.Class
            "struct" => AstClassType.Struct
            "interface" => AstClassType.Interface
            "enum" => AstClassType.Enum
        })

        let name = this.parseString(match.getGroupValue("name"))
        let generics: ?List<AstGenericDecl> = null
        if match.hasGroup("generics") {
            generics = this.parseGenericDecls(match.getGroupValue("generics"))
        }

        return new AstClass {
            type
            modifiers
            name
            generics
        }
    }

    parseProgram(match: RuleMatch): AstKeidProgram {
        let namespaceMatch = match.getGroupValue("namespace").getGroupValue("namespace")
        let namespace = this.parseString(namespaceMatch)
        let imports = List.empty<AstToken<string>>()
        let classes = List.empty<AstClass>()

        for statement in match.getGroup("statements") {
            if statement.rule == "ImportStatement" {
                let modules = statement.getGroup("modules")
                for module in modules {
                    imports.push(this.parseString(module))
                }
            } else if statement.rule == "ClassDecl" {
                classes.push(this.parseClass(statement))
            }
        }

        return new AstKeidProgram {
            namespace
            imports
            classes
        }
    }
}

public function parseKeidSource(programText: string): AstKeidProgram {
    let syntaxDefFile = File.open("../keid/assets/compiler/syntax.ksdl", FileOpenMode.ReadOnly)
    let syntaxDef = string.fromUtf8(syntaxDefFile.readAllBytes())
    syntaxDefFile.close()

    let parser = KsdlParser.fromKsdl(syntaxDef)
    let programRule = parser.getRule("Program")
    let reader = TokenReader.create(programText)
    let parseResult = programRule.parse(reader)
    if !reader.isFinished {
        std::io.println("At: ", reader.currentText.substringBefore(20))
        throw Error.create(string.format("Failed parsing rule: ", reader.currentRule!.name))
    }
    match parseResult {
        Success { match, } => {
            std::io.println(match.toString())

            let keidParser = new KeidParser {
                source = programText
            }
            return keidParser.parseProgram(match)
        }
        HardFail { rule, statement, result, } => {
            std::io.println("Failed parsing statement: ", Class.fromInstance(statement).name)
            std::io.println("in rule: ", rule.name)
        }
        _ => {}
    }

    throw Error.create("Parse failure!")
}
