namespace keidc::parser

import (
    core::collections
    core::error
    core::string
    core::object
    keidc::ast
    keidc::common
    keidc::ksdl
    keidc::types
    std::fs
    std::io
)

function tokenize<T>(loc: TokenLocation, node: T): AstToken<T> {
    return new AstToken<T> {
        node
        loc
    }
}

function tokenizeIdentifier(token: LexerToken): AstToken<string> {
    return new AstToken<string> {
        node = token.kind.identifier()
        loc = token.loc
    }
}

function parseQualifiedPath(ast: RuleMatch): AstToken<string> {
    if ast.ruleName != "QualifiedPath" {
        throw Error.create(string.format("parseQualifiedPath for invalid rule '", ast.ruleName, "'"))
    }
    let fullPath = StringBuilder.withCapacity(ast.loc.length)
    let pathGroup = ast.getGroup("path")
    for i in range.create(pathGroup.length - 1) {
        let ident = pathGroup.get(i).token().kind.identifier()
        fullPath.append(ident)
        fullPath.append(".")
    }
    let lastIdent = pathGroup.get(pathGroup.length - 1).token().kind.identifier()
    fullPath.append(lastIdent)
    return tokenize<string>(ast.loc, fullPath.toString())
}

public enum PrattParserAffix {
    Prefix
    Infix
    Postfix
}

implement ToString for PrattParserAffix {
    toString(): string => match this {
        Prefix => "Prefix"
        Infix => "Infix"
        Postfix => "Postfix"
    }
}

const PRECEDENCE_STEP: uint32 = 10
const OPERATORS: [PrattParserOperator] = new PrattParserOperator[
    PrattParserOperator.create(PrattParserAffix.Infix,   ".",   AstOperator.MemberAccess,        PRECEDENCE_STEP * 1),
    PrattParserOperator.create(PrattParserAffix.Infix,   "??",  AstOperator.NullCoalesce,        PRECEDENCE_STEP * 2),
    PrattParserOperator.create(PrattParserAffix.Infix,   "||",  AstOperator.BooleanOr,           PRECEDENCE_STEP * 3),
    PrattParserOperator.create(PrattParserAffix.Infix,   "&&",  AstOperator.BooleanAnd,          PRECEDENCE_STEP * 4),
    PrattParserOperator.create(PrattParserAffix.Infix,   "==",  AstOperator.Equals,              PRECEDENCE_STEP * 5),
    PrattParserOperator.create(PrattParserAffix.Infix,   "!=",  AstOperator.NotEquals,           PRECEDENCE_STEP * 5),
    PrattParserOperator.create(PrattParserAffix.Infix,   "<",   AstOperator.LessThan,            PRECEDENCE_STEP * 6),
    PrattParserOperator.create(PrattParserAffix.Infix,   "<=",  AstOperator.LessThanOrEquals,    PRECEDENCE_STEP * 6),
    PrattParserOperator.create(PrattParserAffix.Infix,   ">",   AstOperator.GreaterThan,         PRECEDENCE_STEP * 6),
    PrattParserOperator.create(PrattParserAffix.Infix,   ">=",  AstOperator.GreaterThanOrEquals, PRECEDENCE_STEP * 6),
    PrattParserOperator.create(PrattParserAffix.Infix,   "<<",  AstOperator.LeftShift,           PRECEDENCE_STEP * 7),
    PrattParserOperator.create(PrattParserAffix.Infix,   ">>",  AstOperator.RightShift,          PRECEDENCE_STEP * 7),
    PrattParserOperator.create(PrattParserAffix.Infix,   "+",   AstOperator.Add,                 PRECEDENCE_STEP * 8),
    PrattParserOperator.create(PrattParserAffix.Infix,   "-",   AstOperator.Subtract,            PRECEDENCE_STEP * 8),
    PrattParserOperator.create(PrattParserAffix.Infix,   "*",   AstOperator.Multiply,            PRECEDENCE_STEP * 9),
    PrattParserOperator.create(PrattParserAffix.Infix,   "/",   AstOperator.Divide,              PRECEDENCE_STEP * 9),
    PrattParserOperator.create(PrattParserAffix.Infix,   "%",   AstOperator.Modulus,             PRECEDENCE_STEP * 9),
    PrattParserOperator.create(PrattParserAffix.Infix,   "as",  AstOperator.As,                  PRECEDENCE_STEP * 10),
    PrattParserOperator.create(PrattParserAffix.Prefix,  "not", AstOperator.Not,                 PRECEDENCE_STEP * 11),
    PrattParserOperator.create(PrattParserAffix.Prefix,  "...", AstOperator.Spread,              PRECEDENCE_STEP * 12),
    PrattParserOperator.create(PrattParserAffix.Postfix, "!",   AstOperator.NonNullAssertion,    PRECEDENCE_STEP * 13),
]

public class PrattParserOperator {
    affix: PrattParserAffix
    text: string
    ast: AstOperator
    precedence: uint32

    public static create(affix: PrattParserAffix, text: string, ast: AstOperator, precedence: uint32): PrattParserOperator => new PrattParserOperator { affix, text, ast, precedence, }
}

implement ToString for PrattParserOperator {
    toString(): string => string.format("PrattParserOperator(affix=", this.affix.toString(), ", text=", this.text, ", ast=", this.ast.toString(), ", precedence=" + this.precedence.toString(), ")")
}

public class PrattParser {
    source: string
    parts: List<ParserMatch>
    offset: usize
    operators: [PrattParserOperator]
    primaryParser: function (ast: ParserMatch) => AstToken<AstExpr>
    prefixParser: function (op: AstToken<AstOperator>, operand: AstToken<AstExpr>) => AstToken<AstExpr>
    infixParser: function (lhs: AstToken<AstExpr>, op: AstToken<AstOperator>, rhs: AstToken<AstExpr>) => AstToken<AstExpr>
    postfixParser: function (operand: AstToken<AstExpr>, op: AstToken<AstOperator>) => AstToken<AstExpr>

    public parse(): AstToken<AstExpr> {
        return this.expr(0)
    }

    findOperator(text: string): ?PrattParserOperator {
        for operator in this.operators {
            if operator.text == text {
                return operator
            }
        }

        return null
    }

    expr(rbp: uint32): AstToken<AstExpr> {
        let lhs = this.nud()
        while rbp < this.lbp() {
            lhs = this.led(lhs)
        }
        return lhs
    }

    lbp(): uint32 {
        if this.offset == this.parts.length {
            return 0
        }
        let next = this.parts.get(this.offset)
        match next {
            Token { token, } => {
                match token.kind {
                    Operator { op, } => {
                        let prattOp = this.findOperator(op)
                        if prattOp == null {
                            throw Error.create("No such operator: " + op)
                        }
                        return prattOp!.precedence
                    }
                }
            }
        }
        return 0
    }

    led(lhs: AstToken<AstExpr>): AstToken<AstExpr> {
        let next = this.parts.get(this.offset)
        this.offset += 1
        match next {
            Rule { rule, } => {
                match rule.ruleName {
                    "InfixOperator" => {
                        let op = rule.getGroupValue("op").token().kind.operator()
                        let infixOperator = this.findOperator(op)
                        if infixOperator == null {
                            throw Error.create("No such operator: " + op)
                        }
                        let rhs = this.expr(infixOperator!.precedence)
                        return (this.infixParser)(lhs, tokenize<AstOperator>(rule.loc, infixOperator!.ast), rhs)
                    }
                    "PostfixOperator" => {
                        let op2 = rule.getGroupValue("op").token().kind.operator()
                        let postfixOperator = this.findOperator(op2)
                        if postfixOperator == null {
                            throw Error.create("No such operator: " + op2)
                        }
                        return (this.postfixParser)(lhs, tokenize<AstOperator>(rule.loc, postfixOperator!.ast))
                    }
                    _ => {}
                }
            }
        }
        throw Error.create("expected infix or postfix expression")
    }

    nud(): AstToken<AstExpr> {
        let next = this.parts.get(this.offset)
        this.offset += 1
        match next {
            Rule { rule, } => {
                if rule.ruleName == "PrefixOperator" {
                    let op = rule.getGroupValue("op").token().kind.operator()
                    let prefixOperator = this.findOperator(op)
                    if prefixOperator == null {
                        throw Error.create("No such operator: " + op)
                    }
                    let rhs = this.expr(prefixOperator!.precedence - 1)
                    return (this.prefixParser)(tokenize<AstOperator>(rule.loc, prefixOperator!.ast), rhs)
                }
            }
        }
        return (this.primaryParser)(next)
    }
}

class KeidParser {
    source: string

    parseGenericDecls(ast: RuleMatch): List<AstGenericDecl> {
        let decls = List.empty<AstGenericDecl>()
        for decl in ast.getGroup("decls") {
            decls.push(new AstGenericDecl {
                name = tokenizeIdentifier(decl.rule().getGroupValue("name").token())
            })
        }
        return decls
    }

    parseGenericArgs(ast: RuleMatch, group: string): ?List<AstToken<ComplexType>> {
        if ast.hasGroup(group) {
            let args = List.empty<AstToken<ComplexType>>()
            for arg in ast.getGroupValue(group).rule().getGroup("args") {
                args.push(this.parseValueType(arg.rule()))
            }
            return args
        }
        return null
    }

    parseGenericArgsNodes(ast: RuleMatch): List<ComplexType> {
        let args = List.empty<ComplexType>()
        if ast.hasGroup("generics") {
            for arg in ast.getGroupValue("generics").rule().getGroup("args") {
                args.push(this.parseValueTypeNode(arg.rule()))
            }
        }
        return args
    }

    parseModifers(parentAstNode: RuleMatch): List<AstToken<Modifier>> {
        if parentAstNode.hasGroup("modifiers") {
            let astModifiers = parentAstNode.getGroup("modifiers")
            let modifiers = List.withCapacity<AstToken<Modifier>>(astModifiers.length)
            for astModifier in astModifiers {
                let modifierToken = astModifier.token()
                let modifier = match modifierToken.kind.keyword() {
                    "public" => Modifier.Public
                    "extern" => Modifier.Extern
                    "static" => Modifier.Static
                    // TODO: fix this not compiling _ => throw Error.create("ParseError: invalid modifier: " + text)
                }
                modifiers.push(new AstToken<Modifier> {
                    node = modifier
                    loc = modifierToken.loc
                })
            }
            return modifiers
        }
        return List.empty<AstToken<Modifier>>()
    }

    parseNewSliceExpr(ast: RuleMatch): AstToken<AstExpr> {
        let type = this.parseValueType(ast.getGroupValue("type").rule())
        let initialValue = this.parseExpr(ast.getGroupValue("initialValue").rule())
        let length = this.parseExpr(ast.getGroupValue("length").rule())
        return tokenize<AstExpr>(ast.loc, new AstExpr.NewSlice {
            type
            initialValue
            length
        })
    }

    parseFuncCallExpr(ast: RuleMatch): AstToken<AstExpr> {
        let callee = match ast.getGroupValue("callee") {
            Rule { rule, } => this.parseExpr(rule)
            Token { token, } => match token.kind {
                Identifier { name, } => tokenize<AstExpr>(token.loc, new AstExpr.Ident {
                    value = name
                })
                _ => unreachable
            }
        }
        let generics = this.parseGenericArgs(ast, "generics")
        let params = List.empty<AstToken<AstExpr>>()
        for param in ast.getGroup("params") {
            params.push(this.parseExpr(param.rule()))
        }
        return tokenize<AstExpr>(ast.loc, new AstExpr.FuncCall {
            callee
            generics
            params
        }) 
    }

    parseThrow(ast: RuleMatch): AstToken<AstExpr> {
        let error = this.parseExpr(ast.getGroupValue("error").rule())
        return tokenize<AstExpr>(ast.loc, new AstExpr.Throw {
            error
        })
    }

    parseIfStatement(ast: RuleMatch): AstStatement {
        let tests = ast.getGroup("tests")
        let conditionalBlocks = ast.getGroup("conditionalBlocks")

        if tests.length != conditionalBlocks.length {
            unreachable
        }

        let conditionals = List.empty<AstIfBlock>()
        for i in range.create(tests.length) {
            let condition = this.parseExpr(tests.get(i).rule())
            let block = this.parseCodeBlock(conditionalBlocks.get(i).rule())
            conditionals.push(new AstIfBlock {
                condition
                block
            })
        }

        let fallback: ?List<AstToken<AstStatement>> = null
        if ast.hasGroup("fallback") {
            fallback = this.parseCodeBlock(ast.getGroupValue("fallback").rule())
        }

        return new AstStatement.IfChain {
            conditionals
            fallback
        }
    }

    parsePrefixExpr(operator: AstToken<AstOperator>, operand: AstToken<AstExpr>): AstToken<AstExpr> {
        return new AstToken<AstExpr> {
            node = new AstExpr.Unary {
                operator
                operand
            }
            loc = operator.loc.joined(operand.loc)
        }
    }

    parseInfixExpr(lhs: AstToken<AstExpr>, operator: AstToken<AstOperator>, rhs: AstToken<AstExpr>): AstToken<AstExpr> {
        return new AstToken<AstExpr> {
            node = new AstExpr.Binary {
                lhs
                operator
                rhs
            }
            loc = lhs.loc.joined(rhs.loc)
        }
    }

    parsePostfixExpr(operand: AstToken<AstExpr>, operator: AstToken<AstOperator>): AstToken<AstExpr> {
        return new AstToken<AstExpr> {
            node = new AstExpr.Unary {
                operator
                operand
            }
            loc = operand.loc.joined(operator.loc)
        }
    }

    parseExprOperand(operand: ParserMatch): AstToken<AstExpr> {
        match operand {
            Rule { rule, } => {
                match rule.ruleName {
                    "GroupingExpr" => return this.parseExprOperand(rule.getGroupValue("expr"))
                    "NewSliceExpr" => return this.parseNewSliceExpr(rule)
                    "FuncCallExpr" => return this.parseFuncCallExpr(rule)
                    _ => throw Error.create(string.format("invalid rule as expr operand '", rule.ruleName, "'"))
                }
            }
            Token { token, } => {
                match token.kind {
                    Identifier { name, } => {
                        return tokenize<AstExpr>(token.loc, new AstExpr.Ident {
                            value = name
                        })
                    }
                    Literal { lit, } => {
                        let astLiteral = match lit {
                            Bool { val, } => new AstExpr.BoolLit {
                                value = val
                            }
                            SignedInteger { val, } => new AstExpr.SignedIntLit {
                                value = val
                            }
                            UnsignedInteger { val, } => new AstExpr.UnsignedIntLit {
                                value = val
                            }
                            String { val, } => new AstExpr.StringLit {
                                value = val
                            }
                            Char { val, } => new AstExpr.CharLit {
                                value = val
                            }
                            Null => AstExpr.NullLit
                        }
                        return tokenize<AstExpr>(token.loc, astLiteral)
                    }
                }
            }
        }
        unreachable
    }

    parseExpr(expr: RuleMatch): AstToken<AstExpr> {
        let pratt = new PrattParser {
            source = this.source
            parts = expr.getGroup("parts")
            offset = 0
            operators = OPERATORS
            primaryParser = this.parseExprOperand
            prefixParser = this.parsePrefixExpr
            infixParser = this.parseInfixExpr
            postfixParser = this.parsePostfixExpr
        }
        return pratt.parse()
    }

    parseBody(bodyDecl: RuleMatch): List<AstToken<AstStatement>> {
        match bodyDecl.ruleName {
            "CodeBlock" => return this.parseCodeBlock(bodyDecl)
            "ArrowBlock" => {
                let exprDecl = bodyDecl.getGroupValue("expr").rule()
                let expr = this.parseExpr(exprDecl)
                let statement = new AstStatement.Expr {
                    value = expr
                }
                return List.from<AstToken<AstStatement>>(tokenize<AstStatement>(exprDecl.loc, statement))
            }
        }

        unreachable
    }

    parseCodeBlock(ast: RuleMatch): List<AstToken<AstStatement>> {
        let statements = List.empty<AstToken<AstStatement>>()
        if ast.hasGroup("statements") {
            for statement in ast.getGroup("statements") {
                let rule = statement.rule()
                let statementAst = match rule.ruleName {
                    "ReturnStatement" => new AstStatement.Return { operand = this.parseExpr(rule.getGroupValue("operand").rule()), }
                    "Expr" => new AstStatement.Expr { value = this.parseExpr(rule), }
                    "UnsafeBlock" => new AstStatement.UnsafeBlock { statements = this.parseCodeBlock(rule.getGroupValue("inner").rule()) }
                    "LetStatement" => new AstStatement.Let { statement = this.parseLet(rule) }
                    "AssignStatement" => new AstStatement.Assign { statement = this.parseAssign(rule) }
                    "ThrowStatement" => new AstStatement.Throw { error = this.parseExpr(rule.getGroupValue("error").rule()) }
                    "IfStatement" => this.parseIfStatement(rule)
                    _ => throw Error.create("NotYetImplemented: block statement: " + rule.ruleName)
                }
                statements.push(tokenize<AstStatement>(rule.loc, statementAst))
            }
        }
        return statements
    }

    parseValueTypeNode(ast: RuleMatch): ComplexType {
        match ast.ruleName {
            "ArrayType" => return new ComplexType.Array {
                element = this.parseValueTypeNode(ast.getGroupValue("elementType").rule())
            }
            "NullableType" => return new ComplexType.Nullable {
                element = this.parseValueTypeNode(ast.getGroupValue("elementType").rule())
            }
            "BasicType" => {
                let path = parseQualifiedPath(ast.getGroupValue("path").rule())
                let generics = this.parseGenericArgsNodes(ast)
                let basic = match path.node {
                    "void"    => BasicType.Void
                    "never"   => BasicType.Never
                    "bool"    => BasicType.Bool
                    "char"    => BasicType.Char
                    "uint8"   => BasicType.UInt8
                    "uint16"  => BasicType.UInt16
                    "uint32"  => BasicType.UInt32
                    "uint64"  => BasicType.UInt64
                    "int8"    => BasicType.Int8
                    "int16"   => BasicType.Int16
                    "int32"   => BasicType.Int32
                    "int64"   => BasicType.Int64
                    "float32" => BasicType.Float32
                    "float64" => BasicType.Float64
                    "usize"   => BasicType.USize
                    "isize"   => BasicType.ISize
                    _ => return new ComplexType.Basic {
                        basic = new BasicType.Ident {
                            ident = new QualifiedIdent {
                                name = path.node
                                generics
                            }
                        }
                    }
                }
                if generics.length > 0 {
                    throw Error.create("parser error: primitive cannot have generics")
                }
                return new ComplexType.Basic {
                    basic
                }
            }
        }

        unreachable
    }

    parseValueType(ast: RuleMatch): AstToken<ComplexType> => tokenize<ComplexType>(ast.loc, this.parseValueTypeNode(ast))

    parseLet(ast: RuleMatch): AstLet {
        let kind = match ast.getGroupValue("kind").token().kind.keyword() {
            "let" => LetKind.Mutable
            "const" => LetKind.Constant
            _ => unreachable
        }
        let name = tokenizeIdentifier(ast.getGroupValue("name").token())
        let valueType: ?AstToken<ComplexType> = null
        if ast.hasGroup("valueType") {
            valueType = this.parseValueType(ast.getGroupValue("valueType").rule())
        }
        let initialValue: ?AstToken<AstExpr> = null
        if ast.hasGroup("initialValue") {
            initialValue = this.parseExpr(ast.getGroupValue("initialValue").rule())
        }

        return new AstLet {
            kind
            name
            valueType
            initialValue
        }
    }

    parseOperator(ast: LexerToken): AstToken<AstOperator> {
        match ast.kind {
            Operator { op, } => {
                for operator in OPERATORS {
                    if operator.text == op {
                        return tokenize<AstOperator>(ast.loc, operator.ast)
                    }
                }
            }
            _ => {}
        }
        throw Error.create(string.format("invalid operator: ", ast.toString()))
    }

    parseSelfOperator(ast: LexerToken): AstToken<AstOperator> {
        match ast.kind {
            Operator { op, } => {
                if op == "=" {
                    return tokenize<AstOperator>(ast.loc, AstOperator.Assign)
                }
                let unself = op.substringBefore(op.length - 1)
                for operator in OPERATORS {
                    if operator.text == unself {
                        return tokenize<AstOperator>(ast.loc, operator.ast)
                    }
                }
            }
            _ => {}
        }
        throw Error.create(string.format("invalid self operator: ", ast.toString()))
    }

    parseAssign(ast: RuleMatch): AstAssign {
        let deref = ast.hasGroup("deref")
        let lhs = this.parseExpr(ast.getGroupValue("lhs").rule())
        let op = this.parseSelfOperator(ast.getGroupValue("op").token())
        let rhs = this.parseExpr(ast.getGroupValue("rhs").rule())

        return new AstAssign {
            deref
            lhs
            op
            rhs
        }
    }

    parseClassField(ast: RuleMatch): AstClassField {
        let modifiers = this.parseModifers(ast)
        let name = tokenizeIdentifier(ast.getGroupValue("name").token())
        let type = this.parseValueType(ast.getGroupValue("type").rule())
        let initialValue: ?AstToken<AstExpr> = null
        if ast.hasGroup("initialValue") {
            initialValue = this.parseExpr(ast.getGroupValue("initialValue").rule())
        }
        return new AstClassField {
            modifiers
            name
            type
            initialValue
        }
    }

    parseFunctionParam(paramDecl: RuleMatch): AstFunctionParam {
        return new AstFunctionParam {
            name = tokenizeIdentifier(paramDecl.getGroupValue("name").token())
            type = this.parseValueType(paramDecl.getGroupValue("type").rule())
        }
    }

    parseFunction(decl: RuleMatch): AstFunction {
        let modifiers = this.parseModifers(decl)
        let name = tokenizeIdentifier(decl.getGroupValue("name").token())
        let generics: ?List<AstGenericDecl> = null
        if decl.hasGroup("generics") {
            generics = this.parseGenericDecls(decl.getGroupValue("generics").rule())
        }
        let params = List.empty<AstFunctionParam>()
        let paramsDecl = decl.getGroupValue("params").rule()
        if paramsDecl.hasGroup("params") {
            for paramDecl in paramsDecl.getGroup("params") {
                params.push(this.parseFunctionParam(paramDecl.rule()))
            }
        }

        let returnType: ?AstToken<ComplexType> = null
        if decl.hasGroup("returnType") {
            returnType = this.parseValueType(decl.getGroupValue("returnType").rule())
        }

        let varargs = VarargsMode.None
        if decl.hasGroup("nativeVarargs") {
            varargs = VarargsMode.Native
        } else if decl.hasGroup("varargs") {
            let paramDecl = decl.getGroupValue("varargs").rule().getGroupValue("param").rule()
            varargs = new VarargsMode.Array {
                param = this.parseFunctionParam(paramDecl)
            }
        }

        let body: ?List<AstToken<AstStatement>> = null
        if decl.hasGroup("body") {
            body = this.parseBody(decl.getGroupValue("body").rule())
        }

        return new AstFunction {
            modifiers
            name
            generics
            params
            returnType
            varargs
            body
        }
    }

    parseClass(ast: RuleMatch): AstClass {
        let modifiers = this.parseModifers(ast)
        let classKindAst = ast.getGroupValue("kind").token()
        let kind = tokenize<ObjectKind>(classKindAst.loc, match classKindAst.kind.keyword() {
            "class" => ObjectKind.Class
            "struct" => ObjectKind.Struct
            "interface" => ObjectKind.Interface
            "enum" => ObjectKind.Enum
        })

        let name = tokenizeIdentifier(ast.getGroupValue("name").token())
        let generics: ?List<AstGenericDecl> = null
        if ast.hasGroup("generics") {
            generics = this.parseGenericDecls(ast.getGroupValue("generics").rule())
        }

        let superclass: ?AstToken<string> = null
        let superclassGenerics: ?List<AstToken<ComplexType>> = null
        if ast.hasGroup("extends") {
            let extendsDecl = ast.getGroupValue("extends").rule()
            let superclassDecl = extendsDecl.getGroupValue("superclass").rule()
            superclass = parseQualifiedPath(superclassDecl)
            superclassGenerics = this.parseGenericArgs(extendsDecl, "generics")
        }

        let constructor: ?List<AstToken<AstStatement>> = null
        let destructor: ?List<AstToken<AstStatement>> = null
        let fields = List.empty<AstClassField>()
        let methods = List.empty<AstFunction>()
        if ast.hasGroup("statements") {
            let statements = ast.getGroup("statements")
            for statement in statements {
                let rule = statement.rule()
                match rule.ruleName {
                    "ConstructorDecl" => constructor = this.parseBody(rule.getGroupValue("body").rule())
                    "DestructorDecl"  => destructor  = this.parseBody(rule.getGroupValue("body").rule())
                    "FieldDecl" => {
                        fields.push(this.parseClassField(rule))
                    }
                    "MethodDecl" => {
                        methods.push(this.parseFunction(rule))
                    }
                    _ => {
                        io.println("TODO: Class-level statement: ", rule.ruleName)
                    }
                }
            }
        }

        return new AstClass {
            kind
            modifiers
            name
            generics
            superclass
            superclassGenerics
            constructor
            destructor
            fields
            methods
        }
    }

    parseImplement(ast: RuleMatch): AstImplement {
        let generics: ?List<AstGenericDecl> = null
        if ast.hasGroup("generics") {
            generics = this.parseGenericDecls(ast.getGroupValue("generics").rule())
        }

        let interface = parseQualifiedPath(ast.getGroupValue("interface").rule())
        let interfaceGenerics: ?List<AstToken<ComplexType>> = this.parseGenericArgs(ast, "interfaceGenerics")
        let target = parseQualifiedPath(ast.getGroupValue("target").rule())
        let targetGenerics: ?List<AstToken<ComplexType>> = this.parseGenericArgs(ast, "targetGenerics")

        let methods = List.empty<AstFunction>()

        return new AstImplement {
            generics
            interface
            interfaceGenerics
            target
            targetGenerics
            methods
        }
    }

    parseProgram(ast: RuleMatch): AstKeidProgram {
        let namespaceAst = ast.getGroupValue("namespace").rule().getGroupValue("namespace").rule()
        let namespace = parseQualifiedPath(namespaceAst)
        let imports = List.empty<AstToken<string>>()
        let classes = List.empty<AstClass>()
        let impls = List.empty<AstImplement>()
        let functions = List.empty<AstFunction>()
        let globals = List.empty<AstLet>()

        if ast.hasGroup("statements") {
            for statement in ast.getGroup("statements") {
                let rule = statement.rule()
                match rule.ruleName {
                    "ImportStatement" => {
                        let modules = rule.getGroup("modules")
                        for module in modules {
                            imports.push(parseQualifiedPath(module.rule()))
                        }
                    }
                    "ClassDecl" => {
                        classes.push(this.parseClass(rule))
                    }
                    "EnumDecl" => {
                        classes.push(this.parseClass(rule))
                    }
                    "ImplementDecl" => {
                        impls.push(this.parseImplement(rule))
                    }
                    "FunctionDecl" => {
                        functions.push(this.parseFunction(rule))
                    }
                    "LetStatement" => {
                        globals.push(this.parseLet(rule))
                    }
                    _ => throw Error.create("NotYetImplemented: root statement: " + rule.ruleName)
                }
            }
        }

        return new AstKeidProgram {
            source = this.source
            namespace
            imports
            classes
            impls
            functions
            globals
        }
    }
}

class KeidPreprocessor {
    ast: RuleMatch
    macroDecls: List<RuleMatch>
    macroCalls: List<RuleMatch>

    public static create(ast: RuleMatch, macroDecls: List<RuleMatch>): KeidPreprocessor => new KeidPreprocessor {
        ast
        macroDecls
        macroCalls = List.empty<RuleMatch>()
    }

    public findMacroCalls(): bool {
        for statement in this.ast.getGroup("statements") {
            match statement {
                Rule { rule, } => {
                    if rule.ruleName == "MacroCall" {
                        this.macroCalls.push(rule)
                    }
                }
                _ => {}
            }
        }
        return this.macroCalls.length > 0
    }

    public preprocess(): List<LexerToken> {
        io.println("Preprocess: decls = ", this.macroDecls.length.toString(), ", calls = ", this.macroCalls.length.toString())
        let tokens = this.collectRegularTokens()
        for macroCall in this.macroCalls {
            let macroName = macroCall.getGroupValue("name").token().kind.identifier()
            let macroParamValues = macroCall.getGroup("params")
            let macroDecl = this.findMacroDecl(macroName)
            let macroParamDecls = macroDecl.getGroup("params")
            let paramNames = List.withCapacity<string>(macroParamDecls.length)
            for macroParamDecl in macroParamDecls {
                paramNames.push(macroParamDecl.rule().getGroupValue("name").token().kind.identifier())
            }
            let macroBody = macroDecl.getGroup("body")
            let bodyTokens = List.withCapacity<LexerToken>(macroBody.length)
            for bodyToken in macroBody {
                bodyTokens.push(bodyToken.token())
            }
            let processedBody = this.preprocessMacroCall(paramNames, macroParamValues, bodyTokens)
            tokens.extend(processedBody)
        }
        return tokens
    }

    /// Returns all tokens outside of macro calls and definitions.
    collectRegularTokens(): List<LexerToken> {
        let tokens = List.empty<LexerToken>()
        for statement in this.ast.getGroup("statements") {
            match statement {
                Token { token, } => {
                    tokens.push(token)
                }
                _ => {}
            }
        }
        return tokens
    }

    findMacroDecl(name: string): RuleMatch {
        for macroDecl in this.macroDecls {
            let macroName = macroDecl.getGroupValue("name").token().kind.identifier()
            if macroName == name {
                return macroDecl
            }
        }
        throw Error.create(string.format("no such MacroDecl '", name, "'"))
    }
    
    replaceIdentifierName(paramName: string, paramValue: ParserMatch, identifierName: string, loc: TokenLocation): LexerToken {
        match paramValue {
            Token { token, } => {
                match token.kind {
                    Identifier { name, } => {
                        return new LexerToken {
                            kind = new LexerTokenKind.Identifier {
                                name = identifierName.replaceFirst(paramName, name)
                            }
                            loc
                            originalLoc = token.loc
                        }
                        
                    }
                    _ => {}
                }
            }
            _ => {}
        }
        throw Error.create(string.format("param '", paramName, "' should be an identifier"))
    }

    preprocessToken(paramNames: List<string>, paramValues: List<ParserMatch>, bodyToken: LexerToken, name: string): List<LexerToken> {
        for p in range.create(paramNames.length) {
            let paramName = paramNames.get(p)
            let paramValue = paramValues.get(p)
            if paramName == name {
                match paramValue {
                    Rule { rule, } => {
                        return rule.getAllTokens()
                    }
                    Token { token, } => {
                        token.originalLoc = bodyToken.loc
                        return List.from<LexerToken>(token)
                    }
                }
            }
            if name.contains(paramName) {
                return List.from<LexerToken>(this.replaceIdentifierName(paramName, paramValue, name, bodyToken.loc))
            }
        }
        return List.from<LexerToken>(bodyToken)
    }

    preprocessMacroCall(paramNames: List<string>, paramValues: List<ParserMatch>, body: List<LexerToken>): List<LexerToken> {
        let processedTokens = List.withCapacity<LexerToken>(body.length)
        for bodyToken in body {
            match bodyToken.kind {
                Identifier { name, } => {
                    processedTokens.extend(this.preprocessToken(paramNames, paramValues, bodyToken, name))
                    continue
                }
            }
            processedTokens.push(bodyToken)
        }
        return processedTokens
    }
}

public function createPreprocessor(): KsdlParser {
    let syntaxDefFile = File.open("../keid/assets/compiler/preprocessor.ksdl", FileOpenMode.ReadOnly)
    let syntaxDef = string.fromUtf8(syntaxDefFile.readAllBytes())
    syntaxDefFile.close()

    return KsdlParser.fromKsdl(syntaxDef)
}

public function createParser(): KsdlParser {
    let syntaxDefFile = File.open("../keid/assets/compiler/syntax.ksdl", FileOpenMode.ReadOnly)
    let syntaxDef = string.fromUtf8(syntaxDefFile.readAllBytes())
    syntaxDefFile.close()

    return KsdlParser.fromKsdl(syntaxDef)
}

function findMacroDecls(ast: RuleMatch): List<RuleMatch> {
    let decls = List.empty<RuleMatch>()
    for statement in ast.getGroup("statements") {
        match statement {
            Rule { rule, } => {
                if rule.ruleName == "MacroDecl" {
                    decls.push(rule)
                }
            }
            _ => {}
        }
    }
    return decls
}

function runPreprocessorParser(preprocessor: KsdlParser, reader: TokenReader, stream: TokenStream, file: string, programText: string): RuleMatch {
    let preprocesserRule = preprocessor.getRule("PreprocessorProgram")
    let preprocessResult = preprocesserRule.parse(stream)
    if !stream.isFinished {
        reader.cursor = stream.currentToken.loc.start
        let pos = reader.documentPosition
        io.println("failed preprocessing rule '",
            stream.currentRule!.name,
            "' at ",
            stream.currentToken.name,
            " '",
            stream.currentToken.loc.getText(programText),
            "' @ ",
            file,
            ":",
            pos.line.toString(),
            ":",
            pos.col.toString(),
        )
        for i in range.create(10) {
            if stream.isFinished {
                break
            }
            stream.next()
            io.println("next token: ", stream.currentToken.name, " '", stream.currentToken.loc.getText(programText), "'")
        }
        throw Error.create("failed preprocessing rule")
    }

    match preprocessResult {
        Success { match, } => {
            return match.rule()
        }
        HardFail { rule, statement, result, } => {
            throw Error.create(string.format("Failed preprocessing statement '", Class.fromInstance(statement).name, "' in rule '", rule.name, "'"))
        }
        _ => {}
    }

    unreachable
}

function preprocess(preprocessor: KsdlParser, reader: TokenReader, stream: TokenStream, file: string, programText: string, macroDecls: List<RuleMatch>): List<LexerToken> {
    let result = runPreprocessorParser(preprocessor, reader, stream, file, programText)
    let kp = KeidPreprocessor.create(result, macroDecls)
    if kp.findMacroCalls() {
        let processedTokens = kp.preprocess()
        let processedStream = TokenStream.create(processedTokens)
        return preprocess(preprocessor, reader, processedStream, file, programText, macroDecls)
    }
    return stream.tokens
}

public function parseKeidSource(preprocessor: KsdlParser, parser: KsdlParser, file: string): AstKeidProgram {
    let programFile = File.open(file, FileOpenMode.ReadOnly)
    let programText = String.fromUtf8(programFile.readAllBytes())
    programFile.close()

    let reader = TokenReader.create(programText)
    let tokens = ksdl.tokenize(reader)
    let stream = TokenStream.create(tokens)

    let initialPreprocessResult = runPreprocessorParser(preprocessor, reader, stream, file, programText)
    let macroDecls = findMacroDecls(initialPreprocessResult)

    stream.offset = 0
    let processedTokens = preprocess(preprocessor, reader, stream, file, programText, macroDecls)
    let processedStream = TokenStream.create(processedTokens)

    let programRule = parser.getRule("Program")
    let parseResult = programRule.parse(processedStream)
    if !stream.isFinished {
        reader.cursor = stream.currentToken.loc.start
        let pos2 = reader.documentPosition
        io.println("failed parsing rule '",
            stream.currentRule!.name,
            "' at ",
            stream.currentToken.name,
            " '",
            stream.currentToken.loc.getText(programText),
            "' @ ",
            file,
            ":",
            pos2.line.toString(),
            ":",
            pos2.col.toString(),
        )
        for i in range.create(10) {
            if stream.isFinished {
                break
            }
            stream.next()
            io.println("next token: ", stream.currentToken.name, " '", stream.currentToken.loc.getText(programText), "'")
        }
        throw Error.create("failed parsing rule")
    }
    match parseResult {
        Success { match, } => {
            let keidParser = new KeidParser {
                source = programText
            }
            return keidParser.parseProgram(match.rule())
        }
        HardFail { rule, statement, result, loc, } => {
            io.println("Failed parsing statement: ", Class.fromInstance(statement).name)
            io.println("in rule ", rule.name)

            reader.cursor = loc.start
            let pos3 = reader.documentPosition
            io.println("expecting ",
                statement.describe(),
                " at ",
                file,
                ":",
                pos3.line.toString(),
                ":",
                pos3.col.toString(),
            )
        }
        _ => {}
    }

    throw Error.create("Parse failure!")
}
