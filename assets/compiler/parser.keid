namespace keidc::parser

import (
    core::collections
    core::error
    core::object
    keidc::ast
    keidc::ksdl
    std::fs
)

function tokenize<T>(match: RuleMatch, node: T): AstToken<T> {
    return new AstToken<T> {
        node
        loc = match.token
    }
}

public enum PrattParserAffix {
    Prefix
    Infix
    Postfix
}

const PRECEDENCE_STEP: uint32 = 10
const OPERATORS: [PrattParserOperator] = new PrattParserOperator[
    PrattParserOperator.create(PrattParserAffix.Infix, ".", AstOperator.MemberAccess, PRECEDENCE_STEP * 1),
    PrattParserOperator.create(PrattParserAffix.Infix, "??", AstOperator.NullCoalesce, PRECEDENCE_STEP * 2),
    PrattParserOperator.create(PrattParserAffix.Infix, "||", AstOperator.BooleanOr, PRECEDENCE_STEP * 3),
    PrattParserOperator.create(PrattParserAffix.Infix, "&&", AstOperator.BooleanAnd, PRECEDENCE_STEP * 4),
    PrattParserOperator.create(PrattParserAffix.Infix, "==", AstOperator.Equals, PRECEDENCE_STEP * 5),
    PrattParserOperator.create(PrattParserAffix.Infix, "!=", AstOperator.NotEquals, PRECEDENCE_STEP * 5),
    PrattParserOperator.create(PrattParserAffix.Infix, "<", AstOperator.LessThan, PRECEDENCE_STEP * 6),
    PrattParserOperator.create(PrattParserAffix.Infix, "<=", AstOperator.LessThanOrEquals, PRECEDENCE_STEP * 6),
    PrattParserOperator.create(PrattParserAffix.Infix, ">", AstOperator.GreaterThan, PRECEDENCE_STEP * 6),
    PrattParserOperator.create(PrattParserAffix.Infix, ">=", AstOperator.GreaterThanOrEquals, PRECEDENCE_STEP * 6),
    PrattParserOperator.create(PrattParserAffix.Infix, "<<", AstOperator.LeftShift, PRECEDENCE_STEP * 7),
    PrattParserOperator.create(PrattParserAffix.Infix, ">>", AstOperator.RightShift, PRECEDENCE_STEP * 7),
    PrattParserOperator.create(PrattParserAffix.Infix, "+", AstOperator.Add, PRECEDENCE_STEP * 8),
    PrattParserOperator.create(PrattParserAffix.Infix, "-", AstOperator.Subtract, PRECEDENCE_STEP * 8),
    PrattParserOperator.create(PrattParserAffix.Infix, "*", AstOperator.Multiply, PRECEDENCE_STEP * 9),
    PrattParserOperator.create(PrattParserAffix.Infix, "/", AstOperator.Divide, PRECEDENCE_STEP * 9),
    PrattParserOperator.create(PrattParserAffix.Infix, "%", AstOperator.Modulus, PRECEDENCE_STEP * 9),
    PrattParserOperator.create(PrattParserAffix.Infix, "as", AstOperator.As, PRECEDENCE_STEP * 10),
    PrattParserOperator.create(PrattParserAffix.Prefix, "not", AstOperator.Not, PRECEDENCE_STEP * 11),
    PrattParserOperator.create(PrattParserAffix.Prefix, "...", AstOperator.Spread, PRECEDENCE_STEP * 12),
    PrattParserOperator.create(PrattParserAffix.Postfix, "!", AstOperator.NonNullAssertion, PRECEDENCE_STEP * 13),
]

public struct PrattParserOperator {
    affix: PrattParserAffix
    text: string
    ast: AstOperator
    precedence: uint32

    public static create(affix: PrattParserAffix, text: string, ast: AstOperator, precedence: uint32): PrattParserOperator => new PrattParserOperator { affix, text, ast, precedence, }
}

public class PrattParser {
    source: string
    parts: List<RuleMatch>
    offset: usize
    operators: [PrattParserOperator]
    primaryParser: function (match: RuleMatch) => AstToken<AstExpr>
    prefixParser: function (op: AstOperator, operand: AstToken<AstExpr>) => AstToken<AstExpr>
    infixParser: function (lhs: AstToken<AstExpr>, op: AstOperator, rhs: AstToken<AstExpr>) => AstToken<AstExpr>
    postfixParser: function (operand: AstToken<AstExpr>, op: AstOperator) => AstToken<AstExpr>

    public parse(): AstToken<AstExpr> {
        return this.expr(0)
    }

    findOperator(text: string): ?PrattParserOperator {
        for operator in this.operators {
            if operator.text == text {
                return operator
            }
        }

        return null
    }

    expr(rbp: uint32): AstToken<AstExpr> {
        let lhs = this.nud()
        while rbp < this.lbp() {
            lhs = this.led(lhs)
        }
        return lhs
    }

    lbp(): uint32 {
        let next = this.parts.get(this.offset)
        let op = this.findOperator(next.token.getText(this.source))
        if op == null {
            return 0
        }
        return op!.precedence
    }

    led(lhs: AstToken<AstExpr>): AstToken<AstExpr> {
        let next = this.parts.get(this.offset)
        this.offset += 1
        match next.rule {
            "InfixOperator" => {
                let text = next.token.getText(this.source)
                let infixOperator = this.findOperator(text)
                if infixOperator == null {
                    throw Error.create("No such operator: " + text)
                }
                let rhs = this.expr(infixOperator!.precedence)
                return (this.infixParser)(lhs, infixOperator!.ast, rhs)
            }
            "PostfixOperator" => {
                let text2 = next.token.getText(this.source)
                let postfixOperator = this.findOperator(text2)
                if postfixOperator == null {
                    throw Error.create("No such operator: " + text2)
                }
                return (this.postfixParser)(lhs, postfixOperator!.ast)
            }
            _ => throw Error.create("expected infix or postfix expression")
        }
    }

    nud(): AstToken<AstExpr> {
        let next = this.parts.get(this.offset)
        this.offset += 1
        std::io.println(next.rule)
        return match next.rule {
            "PrefixOperator" => {
                let text = next.token.getText(this.source)
                let prefixOperator = this.findOperator(text)
                if prefixOperator == null {
                    throw Error.create("No such operator: " + text)
                }
                let rhs = this.expr(prefixOperator!.precedence - 1)
                return (this.prefixParser)(prefixOperator!.ast, rhs)
            }
            _ => (this.primaryParser)(next)
        }
    }
}

class KeidParser {
    source: string

    parseString(match: RuleMatch): AstToken<string> {
        return tokenize<string>(match, match.token.getText(this.source))
    }

    parseGenericDecls(match: RuleMatch): List<AstGenericDecl> {
        let decls = List.empty<AstGenericDecl>()
        for decl in match.getGroup("decls") {
            let declName = decl.getGroupValue("name")
            decls.push(new AstGenericDecl {
                name = this.parseString(declName)
            })
        }
        return decls
    }

    parseModifers(modifiers: List<AstToken<KeidModifier>>, astModifiers: List<RuleMatch>) {
        for astModifier in astModifiers {
            let text = astModifier.token.getText(this.source)
            let modifier = match text {
                "public" => KeidModifier.Public
                "extern" => KeidModifier.Extern
                "static" => KeidModifier.Static
                // TODO: fix this not compiling _ => throw Error.create("ParseError: invalid modifier: " + text)
            }
            modifiers.push(new AstToken<KeidModifier> {
                node = modifier
                loc = astModifier.token
            })
        }
    }

    parseExpr(expr: RuleMatch): AstToken<AstExpr> {
        let pratt = new PrattParser {
            source = this.source
            parts = expr.getGroup("parts")
            offset = 0
            operators = OPERATORS
            primaryParser = this.parseExprOperand
        }
        return pratt.parse()
    }

    parseCodeBlock(match: RuleMatch): List<AstToken<AstStatement>> {
        let statements = List.empty<AstToken<AstStatement>>()
        if match.hasGroup("statements") {
            for statement in match.getGroup("statements") {
                let ast = match statement.rule {
                    "ReturnStatement" => new AstStatement.Return { operand = this.parseExpr(statement.getGroupValue("operand")), }
                    "Expr" => new AstStatement.Expr { value = this.parseExpr(statement), }
                }
                statements.push(tokenize<AstStatement>(statement, ast))
            }
        }
        return statements
    }

    parseClass(match: RuleMatch): AstClass {
        let modifiers = List.empty<AstToken<KeidModifier>>()
        if match.hasGroup("modifiers") {
            this.parseModifers(modifiers, match.getGroup("modifiers"))
        }

        let typeMatch = match.getGroupValue("type")
        let typeText = typeMatch.token.getText(this.source)
        let type = tokenize<AstClassType>(typeMatch, match typeText {
            "class" => AstClassType.Class
            "struct" => AstClassType.Struct
            "interface" => AstClassType.Interface
            "enum" => AstClassType.Enum
        })

        let name = this.parseString(match.getGroupValue("name"))
        let generics: ?List<AstGenericDecl> = null
        if match.hasGroup("generics") {
            generics = this.parseGenericDecls(match.getGroupValue("generics"))
        }

        let constructor: ?List<AstToken<AstStatement>> = null
        let destructor: ?List<AstToken<AstStatement>> = null
        if match.hasGroup("statements") {
            let statements = match.getGroup("statements")
            for statement in statements {
                match statement.rule {
                    "ConstructorDecl" => constructor = this.parseCodeBlock(statement.getGroupValue("block"))
                    "DestructorDecl"  => destructor  = this.parseCodeBlock(statement.getGroupValue("block"))
                    _ => {
                        std::io.println(statement.rule)
                    }
                }
            }
        }

        return new AstClass {
            type
            modifiers
            name
            generics
            constructor
            destructor
        }
    }

    parseProgram(match: RuleMatch): AstKeidProgram {
        let namespaceMatch = match.getGroupValue("namespace").getGroupValue("namespace")
        let namespace = this.parseString(namespaceMatch)
        let imports = List.empty<AstToken<string>>()
        let classes = List.empty<AstClass>()

        for statement in match.getGroup("statements") {
            if statement.rule == "ImportStatement" {
                let modules = statement.getGroup("modules")
                for module in modules {
                    imports.push(this.parseString(module))
                }
            } else if statement.rule == "ClassDecl" {
                classes.push(this.parseClass(statement))
            }
        }

        return new AstKeidProgram {
            namespace
            imports
            classes
        }
    }
}

public function parseKeidSource(programText: string): AstKeidProgram {
    let syntaxDefFile = File.open("../keid/assets/compiler/syntax.ksdl", FileOpenMode.ReadOnly)
    let syntaxDef = string.fromUtf8(syntaxDefFile.readAllBytes())
    syntaxDefFile.close()

    let parser = KsdlParser.fromKsdl(syntaxDef)
    let programRule = parser.getRule("Program")
    let reader = TokenReader.create(programText)
    let parseResult = programRule.parse(reader)
    if !reader.isFinished {
        std::io.println("At: ", reader.currentText.substringBefore(20))
        throw Error.create(string.format("Failed parsing rule: ", reader.currentRule!.name))
    }
    match parseResult {
        Success { match, } => {
            std::io.println(match.toString())

            let keidParser = new KeidParser {
                source = programText
            }
            return keidParser.parseProgram(match)
        }
        HardFail { rule, statement, result, } => {
            std::io.println("Failed parsing statement: ", Class.fromInstance(statement).name)
            std::io.println("in rule: ", rule.name)
        }
        _ => {}
    }

    throw Error.create("Parse failure!")
}
