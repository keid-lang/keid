// This file defines the Keid syntax in Keid Syntax Definition Language (KSDL).
// The parser for this file can be found in `parser.keid`.
// See "syntax.def.README.md" for documentation regarding the format of this file.

ALIAS NewlineOrComma OR(REPEATED NEWLINE, OPERATOR COMMA)

RULE ArrayType
    OPERATOR [
    $elementType = ALIAS ValueType
    OPERATOR ]
END RULE

RULE NullableType
    OPERATOR ?
    $elementType = ALIAS ValueType
END RULE

RULE BasicType
    $path = RULE QualifiedPath
    $generics = OPTIONAL RULE GenericArgs
END RULE

ALIAS ValueType OR(RULE ArrayType, RULE NullableType, RULE BasicType)

ALIAS Modifier OR(KEYWORD public, KEYWORD static, KEYWORD extern, KEYWORD unsafe)

RULE GenericDecl
    $name = IDENTIFIER
    OPTIONAL REPEATED COMPOUND(OPERATOR :, $constraints = ALIAS ValueType)
END RULE

RULE GenericDecls
    OPERATOR <
    $decls = RULE GenericDecl
    OPTIONAL REPEATED COMPOUND(OPERATOR COMMA, $decls = RULE GenericDecl)
    OPERATOR >
END RULE

RULE GenericArgs
    OPERATOR <
    $args = ALIAS ValueType
    OPTIONAL REPEATED COMPOUND(OPERATOR COMMA, $args = ALIAS ValueType)   
    OPERATOR >
END RULE

RULE AttributeArgs
    OPERATOR (
    OPTIONAL REPEATED COMPOUND($args = LITERAL, OPERATOR COMMA)
    $args = OPTIONAL LITERAL
    OPERATOR )
END RULE

RULE AttributeStatement
    OPERATOR @
    $name = RULE QualifiedPath
    $generics = OPTIONAL RULE GenericArgs
    $args = OPTIONAL RULE AttributeArgs
END RULE

ALIAS Attributes OPTIONAL REPEATED COMPOUND($attributes = RULE AttributeStatement, NEWLINE)

RULE FuncParamDecl
    $name = IDENTIFIER
    OPERATOR :
    $type = ALIAS ValueType
END RULE

RULE FuncVarargsDecl
    OPERATOR ...
    $param = RULE FuncParamDecl
END RULE

RULE FuncNativeVarargsDecl
    OPERATOR ...
END RULE

RULE FuncParamsDecl
    OPERATOR (
    MOVE
    OPTIONAL REPEATED NEWLINE
    OPTIONAL REPEATED COMPOUND($params = RULE FuncParamDecl, OPERATOR COMMA, OPTIONAL REPEATED NEWLINE)
    OPTIONAL OR($varargs = RULE FuncVarargsDecl, $params = RULE FuncParamDecl, $nativeVarargs = RULE FuncNativeVarargsDecl)
    OPTIONAL COMPOUND (OPERATOR COMMA, REPEATED NEWLINE)
    OPERATOR )
END RULE

RULE MethodDecl
    ALIAS Attributes
    $modifiers = OPTIONAL REPEATED ALIAS Modifier
    $name = IDENTIFIER
    $generics = OPTIONAL RULE GenericDecls
    $params = RULE FuncParamsDecl
    MOVE
    OPTIONAL COMPOUND(OPERATOR :, $returnType = ALIAS ValueType)
    $body = OPTIONAL OR(RULE CodeBlock, RULE ArrowBlock)
END RULE

RULE FunctionDecl
    ALIAS Attributes
    $modifiers = OPTIONAL REPEATED ALIAS Modifier
    KEYWORD function
    MOVE
    $name = IDENTIFIER
    $generics = OPTIONAL RULE GenericDecls
    $params = RULE FuncParamsDecl
    MOVE
    OPTIONAL COMPOUND(OPERATOR :, $returnType = ALIAS ValueType)
    $body = OPTIONAL OR(RULE CodeBlock, RULE ArrowBlock)
END RULE

RULE ConstructorDecl
    KEYWORD constructor
    MOVE
    $body = OR(RULE CodeBlock, RULE ArrowBlock)
END RULE

RULE DestructorDecl
    KEYWORD destructor
    MOVE
    $body = OR(RULE CodeBlock, RULE ArrowBlock)
END RULE

RULE GetAccessorDecl
    $modifiers = OPTIONAL REPEATED ALIAS Modifier
    KEYWORD get
    MOVE
    $name = IDENTIFIER
    OPERATOR :
    $type = ALIAS ValueType
    $body = OPTIONAL OR(RULE CodeBlock, RULE ArrowBlock)
END RULE

RULE SetAccessorDecl
    $modifiers = OPTIONAL REPEATED ALIAS Modifier
    KEYWORD set
    MOVE
    $name = IDENTIFIER
    OPERATOR :
    $type = ALIAS ValueType
    $body = OPTIONAL OR(RULE CodeBlock, RULE ArrowBlock)
END RULE

ALIAS AccessorDecl OR(RULE GetAccessorDecl, RULE SetAccessorDecl)

RULE FuncCallExpr
    $callee = OR(RULE GroupingExpr, IDENTIFIER)
    $generics = OPTIONAL RULE GenericArgs
    OPERATOR (
    MOVE
    OPTIONAL REPEATED NEWLINE
    OPTIONAL REPEATED COMPOUND($params = RULE Expr, ALIAS NewlineOrComma)
    $params = OPTIONAL RULE Expr
    OPTIONAL ALIAS NewlineOrComma
    OPERATOR )
END RULE

RULE GroupingExpr
    OPERATOR (
    $expr = RULE Expr
    OPERATOR )
END RULE

RULE MatchTestCatchAll
    OPERATOR _
END RULE

RULE MatchTestEnumWithData
    $variant = IDENTIFIER
    $data = RULE AnonymousType
END RULE

RULE MatchArm
    $test = OR(RULE MatchTestCatchAll, RULE MatchTestEnumWithData, RULE Expr)
    MOVE
    OPERATOR =>
    $statement = ALIAS BlockStatement
END RULE

RULE MatchExpr
    KEYWORD match
    MOVE
    $matchee = RULE Expr
    OPERATOR {
    REPEATED NEWLINE
    OPTIONAL REPEATED COMPOUND($arms = RULE MatchArm, REPEATED NEWLINE)
    OPERATOR }
END RULE

RULE NewExpr
    $type = ALIAS ValueType
    $fields = RULE FieldSet
END RULE

RULE NewArrayExpr
    $type = RULE ArrayType
    OPERATOR (
    $initialValue = RULE Expr
    OPERATOR ,
    $length = RULE Expr
    OPERATOR )
END RULE

RULE ConstArrayExpr
    $type = RULE ArrayType
    OPERATOR {
    OPTIONAL REPEATED COMPOUND($elements = RULE Expr, ALIAS NewlineOrComma)
    OPTIONAL COMPOUND($elements = RULE Expr, OPTIONAL ALIAS NewlineOrComma)
    OPERATOR }
END RULE

RULE DerefExpr
    KEYWORD deref
    $pointer = RULE Expr
END RULE

ALIAS ExprOperand OR(RULE FuncCallExpr, RULE GroupingExpr, RULE MatchExpr, RULE NewArrayExpr, RULE ConstArrayExpr, RULE NewExpr, LITERAL, RULE DerefExpr, RULE ExplicitQualifiedPath, IDENTIFIER)

RULE LetStatementKind
    OR(KEYWORD let, KEYWORD const)
END RULE

RULE LetStatement
    $modifiers = OPTIONAL REPEATED ALIAS Modifier
    $kind = RULE LetStatementKind
    MOVE
    $name = IDENTIFIER
    OPTIONAL COMPOUND(OPERATOR :, $type = ALIAS ValueType)
    OPTIONAL COMPOUND(OPERATOR =, $initialValue = RULE Expr)
END RULE

RULE ReturnStatement
    KEYWORD return
    MOVE
    $operand = OPTIONAL RULE Expr
END RULE

RULE IfStatement
    KEYWORD if
    MOVE
    $tests = RULE Expr
    $conditionalBlocks = RULE CodeBlock
    OPTIONAL REPEATED COMPOUND(KEYWORD else, KEYWORD if, $tests = RULE Expr, $conditionalBlocks = RULE CodeBlock)
    OPTIONAL COMPOUND(KEYWORD else, $fallback = RULE CodeBlock)
END RULE

RULE ForLoop
    KEYWORD for
    $condition = RULE Expr
    $block = RULE CodeBlock
END RULE

RULE ForEachLoop
    KEYWORD for
    $elementName = IDENTIFIER
    KEYWORD in
    MOVE
    $iterable = RULE Expr
    $block = RULE CodeBlock
END RULE

RULE IndefiniteLoop
    KEYWORD for
    $block = RULE CodeBlock
END RULE

RULE OpAssignSelf
    OPERATOR =
END RULE

RULE OpAddSelf
    OPERATOR +=
END RULE

RULE OpSubtractSelf
    OPERATOR -=
END RULE

ALIAS SelfOperator OR(RULE OpAssignSelf, RULE OpAddSelf, RULE OpSubtractSelf)

RULE AssignStatement
    $deref = OPTIONAL KEYWORD deref
    $lhs = RULE Expr
    $op = ALIAS SelfOperator
    MOVE
    $rhs = RULE Expr
END RULE

RULE ThrowStatement
    KEYWORD throw
    MOVE
    $error = RULE Expr
END RULE

// ALIAS BlockStatement OR(RULE TryStatement, RULE BreakStatement, RULE ContinueStatement, RULE WhileLoop, RULE IndefiniteLoop, RULE UnsafeBlock, RULE FixedBlock, RULE CodeBlock, RULE AssignStatement, RULE ImportStatement, RULE LetStatement, RULE ReturnStatement, RULE UnreachableStatement, RULE ThrowStatement, RULE Expr)
ALIAS BlockStatement OR(NEWLINE, RULE ThrowStatement, RULE ReturnStatement, RULE LetStatement, RULE IfStatement, RULE ForEachLoop, RULE ForLoop, RULE IndefiniteLoop, RULE UnsafeBlock, RULE AssignStatement, RULE Expr)

ALIAS BlockStatementNewline COMPOUND($statements = ALIAS BlockStatement, REPEATED NEWLINE)

RULE UnsafeBlock
    KEYWORD unsafe
    $inner = RULE CodeBlock
END RULE

RULE CodeBlock
    OPERATOR {
    MOVE
    REPEATED NEWLINE
    OPTIONAL REPEATED OR(NEWLINE, ALIAS BlockStatementNewline)
    OPERATOR }
END RULE

RULE ArrowBlock
    OPERATOR =>
    MOVE
    $expr = RULE Expr
END RULE

RULE PrefixOperator
    $op = OR(OPERATOR not, OPERATOR ...)
END RULE

RULE InfixOperator
    $op = OR(OPERATOR ., OPERATOR ==, OPERATOR !=, OPERATOR +, OPERATOR -, OPERATOR *, OPERATOR /, OPERATOR %, OPERATOR <<, OPERATOR >>, OPERATOR or, OPERATOR and, OPERATOR <=, OPERATOR >=, OPERATOR <, OPERATOR >, OPERATOR ??)
END RULE

RULE PostfixOperator
    $op = OR(RULE OpNullAssert, RULE OpIndex, RULE OpAs)
END RULE

RULE OpNullAssert
    OPERATOR !
END RULE

RULE OpIndex
    OPERATOR [
    MOVE
    $index = RULE Expr
    OPERATOR ]
END RULE

RULE OpAs
    KEYWORD as
    MOVE
    $type = ALIAS ValueType
END RULE

RULE Expr
    $parts = OPTIONAL REPEATED RULE PrefixOperator
    $parts = ALIAS ExprOperand
    $parts = OPTIONAL REPEATED RULE PostfixOperator
    OPTIONAL REPEATED COMPOUND($parts = RULE InfixOperator, $parts = OPTIONAL REPEATED RULE PrefixOperator, $parts = ALIAS ExprOperand, $parts = OPTIONAL REPEATED RULE PostfixOperator)
END RULE

RULE FieldDecl
    $modifiers = OPTIONAL REPEATED ALIAS Modifier
    $name = IDENTIFIER
    OPERATOR :
    MOVE
    $type = ALIAS ValueType
    OPTIONAL COMPOUND(OPERATOR =, $initialValue = RULE Expr)
END RULE

RULE AssociatedTypeDecl
    KEYWORD type
    $name = IDENTIFIER
    OPTIONAL COMPOUND(OPERATOR =, $aliasee = ALIAS ValueType)
END RULE

ALIAS ClassBodyStatement OR(RULE AssociatedTypeDecl, RULE ConstructorDecl, RULE DestructorDecl, ALIAS AccessorDecl, RULE MethodDecl, RULE FieldDecl)

ALIAS ClassDeclKind OR(KEYWORD class, KEYWORD struct, KEYWORD interface)

RULE ClassExtends
    KEYWORD extends
    MOVE
    $superclass = RULE QualifiedPath
    $generics = OPTIONAL RULE GenericArgs
END RULE

RULE ClassDecl
    $modifiers = OPTIONAL REPEATED ALIAS Modifier
    $kind = ALIAS ClassDeclKind
    MOVE
    $name = IDENTIFIER
    $generics = OPTIONAL RULE GenericDecls
    $extends = OPTIONAL RULE ClassExtends
    OPERATOR {
    REPEATED NEWLINE
    OPTIONAL REPEATED COMPOUND($statements = ALIAS ClassBodyStatement, REPEATED NEWLINE)
    OPERATOR }
END RULE

RULE EnumDecl
    $modifiers = OPTIONAL REPEATED ALIAS Modifier
    $type = KEYWORD enum
    MOVE
    $name = IDENTIFIER
    $generics = OPTIONAL RULE GenericDecls
    OPERATOR {
    REPEATED NEWLINE
    OPTIONAL REPEATED COMPOUND($members = RULE EnumMemberStatement, REPEATED NEWLINE)
    OPTIONAL REPEATED COMPOUND($statements = ALIAS ClassBodyStatement, REPEATED NEWLINE)
    OPERATOR }
END RULE

RULE AnonymousTypeField
    $name = IDENTIFIER
    OPTIONAL COMPOUND(OPERATOR :, $type = ALIAS ValueType)
END RULE

RULE AnonymousType
    OPERATOR {
    MOVE
    OPTIONAL REPEATED NEWLINE
    OPTIONAL REPEATED COMPOUND($fields = RULE AnonymousTypeField, ALIAS NewlineOrComma)
    OPTIONAL COMPOUND($fields = RULE AnonymousTypeField, OPTIONAL ALIAS NewlineOrComma)
    OPERATOR }
END RULE

RULE FieldSetField
    $name = IDENTIFIER
    OPTIONAL COMPOUND(OPERATOR =, $value = RULE Expr)
END RULE

RULE FieldSet
    OPERATOR {
    OPTIONAL REPEATED NEWLINE
    OPTIONAL REPEATED COMPOUND($fields = RULE FieldSetField, ALIAS NewlineOrComma)
    OPERATOR }
END RULE

RULE EnumMemberStatement
    $name = IDENTIFIER
    $data = OPTIONAL RULE AnonymousType
END RULE

RULE ImplementDecl
    KEYWORD implement
    MOVE
    $generics = OPTIONAL RULE GenericDecls
    $interface = IDENTIFIER
    $interfaceGenerics = OPTIONAL RULE GenericArgs
    KEYWORD for
    $target = IDENTIFIER
    $targetGenerics = OPTIONAL RULE GenericArgs
    OPERATOR {
    REPEATED NEWLINE
    OPTIONAL REPEATED COMPOUND($statements = ALIAS ClassBodyStatement, REPEATED NEWLINE)
    OPERATOR }
END RULE

RULE QualifiedPath
    $path = IDENTIFIER
    OPTIONAL REPEATED COMPOUND(OPERATOR ::, $path = IDENTIFIER)
END RULE

RULE ExplicitQualifiedPath
    $path = IDENTIFIER
    OPERATOR ::
    $path = IDENTIFIER
    OPTIONAL REPEATED COMPOUND(OPERATOR ::, $path = IDENTIFIER)
END RULE

RULE NamespaceStatement
    KEYWORD namespace
    MOVE
    $namespace = RULE QualifiedPath
END RULE

RULE ImportStatement
    KEYWORD import
    MOVE
    OPERATOR (
    REPEATED NEWLINE
    $modules = RULE QualifiedPath
    OPTIONAL REPEATED COMPOUND(REPEATED NEWLINE, $modules = RULE QualifiedPath)
    OPTIONAL REPEATED NEWLINE
    OPERATOR )
END RULE

ALIAS RootStatement OR(RULE ImportStatement, RULE LetStatement, RULE ClassDecl, RULE EnumDecl, RULE ImplementDecl, RULE FunctionDecl)

RULE Program
    MOVE
    OPTIONAL REPEATED NEWLINE
    $namespace = RULE NamespaceStatement
    OPTIONAL REPEATED NEWLINE
    OPTIONAL REPEATED COMPOUND($statements = ALIAS RootStatement, REPEATED NEWLINE)
END RULE
