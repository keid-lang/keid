namespace keidc::ksdl

import (
    core::collections
    core::object
)

public enum StatementResult {
    /// Returned by statements when they match with a token result.
    Match {
        matches: List<ParserMatch>
    }
    /// Returned by statements which don't perform matching operations, e.g. `move`.
    /// A matchless result is always considered successful.
    Matchless
    /// Returned by statements when they attempt to match a token and fail.
    Failure
    /// Returned by statements when a hard fail occurs.
    ImmediateFailure {
        rule: Rule
        statement: ParserStatement
        result: Box<StatementResult>
    }
}

public interface ParserStatement {
    /// Returns true if the rule matched, otherwise false.
    execute(stream: TokenStream, state: RuleState): StatementResult
}

public class MoveStatement { }

implement ParserStatement for MoveStatement {
    execute(_: TokenStream, state: RuleState): StatementResult {
        state.moved = true

        return StatementResult.Matchless
    }
}

public class TokenStatement { }

implement ParserStatement for TokenStatement {
    execute(stream: TokenStream, _: RuleState): StatementResult {
        let token = stream.currentToken
        stream.next()
        return new StatementResult.Match {
            matches = List.from<ParserMatch>(new ParserMatch.Token {
                token
            })
        }
    }
}

public class OperatorStatement {
    op: string

    public static create(op: string): OperatorStatement => new OperatorStatement { op, }
}

implement ParserStatement for OperatorStatement {
    execute(stream: TokenStream, _: RuleState): StatementResult {
        let token = stream.currentToken
        match token.kind {
            Operator { op, } => {
                if op == this.op {
                    stream.next()
                    return new StatementResult.Match {
                        matches = List.from<ParserMatch>(new ParserMatch.Token {
                            token
                        })
                    }
                }
            }
            _ => {}
        }
        return StatementResult.Failure
    }
}

public class KeywordStatement {
    keyword: string

    public static create(keyword: string): KeywordStatement => new KeywordStatement { keyword, }
}

implement ParserStatement for KeywordStatement {
    execute(stream: TokenStream, _: RuleState): StatementResult {
        let token = stream.currentToken
        match token.kind {
            Keyword { name, } => {
                if name == this.keyword {
                    stream.next()
                    return new StatementResult.Match {
                        matches = List.from<ParserMatch>(new ParserMatch.Token {
                            token
                        })
                    }
                }
            }
            _ => {}
        }
        return StatementResult.Failure
    }
}

public class LiteralStatement { }

implement ParserStatement for LiteralStatement {
    execute(stream: TokenStream, _: RuleState): StatementResult {
        let token = stream.currentToken
        match token.kind {
            Literal { lit, } => {
                stream.next()
                 return new StatementResult.Match {
                        matches = List.from<ParserMatch>(new ParserMatch.Token {
                            token
                        })
                    }
            }
            _ => {}
        }
        return StatementResult.Failure
    }
}

public class NewlineStatement { }

implement ParserStatement for NewlineStatement {
    execute(stream: TokenStream, _: RuleState): StatementResult {
        match stream.currentToken.kind {
            Newline => {
                stream.next()
                return StatementResult.Matchless
            }
            _ => {}
        }
        return StatementResult.Failure
    }
}

public class IdentifierStatement { }

implement ParserStatement for IdentifierStatement {
    execute(stream: TokenStream, _: RuleState): StatementResult {
        let token = stream.currentToken
        match token.kind {
            Identifier { name, } => {
                stream.next()
                return new StatementResult.Match {
                    matches = List.from<ParserMatch>(new ParserMatch.Token {
                        token
                    })
                }
            }
            _ => {}
        }
        return StatementResult.Failure
    }
}

public class SubruleStatement {
    subrule: Rule

    public static create(subrule: Rule): SubruleStatement => new SubruleStatement { subrule, }
}

implement ParserStatement for SubruleStatement {
    execute(stream: TokenStream, state: RuleState): StatementResult {
        let ruleResult = this.subrule.parse(stream)
        return match ruleResult {
            Success { match, } => new StatementResult.Match {
                matches = List.from<ParserMatch>(match)
            }
            SoftFail => StatementResult.Failure
            HardFail { rule, statement, result } => new StatementResult.ImmediateFailure { rule, statement, result, }
        }
    }
}

public class UntilStatement {
    statement: ParserStatement

    public static create(statement: ParserStatement): UntilStatement => new UntilStatement { statement, }
}

implement ParserStatement for UntilStatement {
    execute(stream: TokenStream, state: RuleState): StatementResult {
        let matches = List.empty<ParserMatch>()
        loop {
            match this.statement.execute(stream, state) {
                Match { matches, } => break
                Matchless => break
                _ => {
                    matches.push(new ParserMatch.Token {
                        token = stream.currentToken
                    })
                    stream.next()
                }
            }
        }
        return new StatementResult.Match {
            matches
        }
    }
}

public class OptionalStatement {
    statement: ParserStatement

    public static create(statement: ParserStatement): OptionalStatement => new OptionalStatement { statement, }
}

implement ParserStatement for OptionalStatement {
    execute(stream: TokenStream, state: RuleState): StatementResult {
        return match this.statement.execute(stream, state) {
            Match { matches, } => new StatementResult.Match { matches, }
            ImmediateFailure { rule, statement, result, } => new StatementResult.ImmediateFailure { rule, statement, result, }
            _ => StatementResult.Matchless
        }
    }
}

public class OrStatement {
    options: List<ParserStatement>

    public static create(options: List<ParserStatement>): OrStatement => new OrStatement { options, }
}

implement ParserStatement for OrStatement {
    execute(stream: TokenStream, state: RuleState): StatementResult {
        let offset = stream.offset
        for option in this.options {
            let result = option.execute(stream, state)
            match result {
                Failure => {
                    stream.offset = offset
                }
                _ => return result
            }
        }
        return StatementResult.Failure
    }
}

public class NotStatement {
    statement: ParserStatement

    public static create(statement: ParserStatement): NotStatement => new NotStatement { statement, }
}

implement ParserStatement for NotStatement {
    execute(stream: TokenStream, state: RuleState): StatementResult {
        return match this.statement.execute(stream, state) {
            Match { matches, } => StatementResult.Failure
            Matchless => StatementResult.Failure
            ImmediateFailure { rule, statement, result, } => new StatementResult.ImmediateFailure { rule, statement, result, }
            Failure => StatementResult.Matchless
        }
    }
}

public class GroupStatement {
    groupName: string
    value: ParserStatement

    public static create(groupName: string, value: ParserStatement): GroupStatement => new GroupStatement { groupName, value, }
}

implement ParserStatement for GroupStatement {
    execute(stream: TokenStream, state: RuleState): StatementResult {
        let result = this.value.execute(stream, state)
        match result {
            Match { matches, } => {
                for group in state.groups {
                    if group.variable == this.groupName {
                        group.values.extend(matches)
                        return result
                    }
                }
                state.groups.push(new RuleMatchGroup {
                    variable = this.groupName
                    values = matches
                })
            }
            _ => {}
        }

        return result
    }
}

public class RepeatedStatement {
    child: ParserStatement
    optional: bool

    public static create(child: ParserStatement, optional: bool): RepeatedStatement => new RepeatedStatement { child, optional, }
}

implement ParserStatement for RepeatedStatement {
    execute(stream: TokenStream, state: RuleState): StatementResult {
        let resultMatches = List.empty<ParserMatch>()
        if !this.optional {
            match this.child.execute(stream, state) {
                Failure => return StatementResult.Failure
                ImmediateFailure { rule, statement, result, } => return new StatementResult.ImmediateFailure { rule, statement, result, }
                Match { matches, } => {
                    resultMatches.extend(matches)
                }
                _ => {}
            }
        }

        loop {
            let offset = stream.offset
            match this.child.execute(stream, state) {
                Failure => {
                    stream.offset = offset
                    break
                }
                ImmediateFailure { rule, statement, result, } => return new StatementResult.ImmediateFailure { rule, statement, result, }
                Match { matches, } => {
                    resultMatches.extend(matches)
                }
                _ => {}
            }
        }

        return new StatementResult.Match {
            matches = resultMatches
        }
    }
}

public class CompoundStatement {
    statements: List<ParserStatement>

    public static create(statements: List<ParserStatement>): CompoundStatement => new CompoundStatement { statements, }
}

implement ParserStatement for CompoundStatement {
    execute(stream: TokenStream, state: RuleState): StatementResult {
        for statement in this.statements {
            match statement.execute(stream, state) {
                ImmediateFailure { rule, statement, result, } => return new StatementResult.ImmediateFailure { rule, statement, result, }
                Failure => return StatementResult.Failure
                _ => {}
            }
        }
        return StatementResult.Matchless
    }
}
