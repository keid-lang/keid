namespace core::object

import (
    core::error
    core::string
    core::ops
)

public interface Default {
    static default(): object
}

public class Object {
}

public class Box<T> {
    element: T
}

public struct Bool {
    value: bool
}

implement ToString for Bool {
    toString(): string {
        if this.value {
            return "true"
        }
        return "false"
    }
}

public struct Char {
    value: char

    public get isWhitespace: bool => this.value == ' ' || this.value == '\n' || this.value == '\r' || this.value == '\t'

    public get isNumber: bool => this.value >= '0' && this.value <= '9'
}

implement ToString for Char {
    toString(): string => new string {
        chars = new char[this.value]
    }
}

macro $IMPL_INT_TYPE(#wrapper, #primitive, #signed)
    public struct #wrapper {
        value: #primitive

        public static parse(s: string): #primitive {
            let val: #primitive = 0
            let place: #primitive = 1
            let sign: #primitive = 1
            let signSpecified = false

            for i in range.create(s.length) {
                // parse from right to left
                let c = s.chars[s.length - i - 1]
                if c == '-' {
                    if signSpecified {
                        throw Error.create("unexpected token '-'")
                    }
                    if !#signed {
                        throw Error.create(string.format("cannot parse a negative integer as an unsigned type"))
                    }
                    sign = -1
                    signSpecified = true
                } else if c == '+' {
                    if signSpecified {
                        throw Error.create("unexpected token '+'")
                    }
                    signSpecified = true
                } else if c.isNumber {
                    if signSpecified {
                        throw Error.create("sign must be the start of the string")
                    }

                    let v = (c - 48) as #primitive
                    val += v * place
                    place *= 10
                } else {
                    throw Error.create(string.format("unexpected token '", c.toString(), "'"))
                }
            }

            return val * sign
        }
    }

    implement ToString for #wrapper {
        toString(): string {
            let current = this.value
            if current == 0 {
                return "0"
            }
            
            let sb = StringBuilder.empty()
            let insertAt: usize = 0

            $IF(#signed,
                ```
                if current < 0 {
                    sb.append("-")
                    insertAt = 1
                }
                ```
            )

            while current != 0 {
                let digit = (current % 10) + 0x30 // converts the digit to its ascii equivalent
                sb.insert(insertAt, digit as char)
                current /= 10
            }

            return sb.toString()
        }
    }

    implement Hash for #wrapper {
        hash(hasher: Hasher) {
            hasher.write(this)
        }
    }
end macro

$IMPL_INT_TYPE(Int8,  int8,  true)
$IMPL_INT_TYPE(Int16, int16, true)
$IMPL_INT_TYPE(Int32, int32, true)
$IMPL_INT_TYPE(Int64, int64, true)
$IMPL_INT_TYPE(ISize, isize, true)

$IMPL_INT_TYPE(UInt8,  uint8,  false)
$IMPL_INT_TYPE(UInt16, uint16, false)
$IMPL_INT_TYPE(UInt32, uint32, false)
$IMPL_INT_TYPE(UInt64, uint64, false)
$IMPL_INT_TYPE(USize,  usize,  false)

// $IMPL_FLOAT_TYPE(Float32, float32)
// $IMPL_FLOAT_TYPE(Float64, float64)
