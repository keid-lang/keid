namespace core::collections

public interface Iterator<T> {
    get next: ?T
}

public interface Iterable<T> {
    get iterator: Iterator<T>
}

public class Range {
    // The range type can be represented as [start..end) for end > start and (start..end] for end < start in interval notation.
    start: usize // inclusive bound
    end: usize   // exclusive bound
    step: isize // -1 or +1
    current: usize

    public static create(start: usize, end: usize): Range {
        let step: isize = 1
        if start > end {
            step = -1
            start -= 1
        }

        return new Range {
            start
            end
            step // TODO:  step = start <= end ? 1 : -1
            current = start
        }
    }
}

implement Iterator<usize> for Range {
    get next: ?usize {
        // TODO:  change to if > 0 else structure
        if this.step == 1 {
            if this.current >= this.end {
                return null
            }
        }
        if this.step == -1 {
            if this.current < this.end {
                return null
            }
            // TODO:  add else structure
            if this.current == this.end {
                this.end += 1
                return this.current
            }
        }

        let tmp = this.current
        this.current = (this.current as isize + this.step) as usize
        return tmp
    }
}

public interface PositionalStorage<T> {
    getElement(index: usize): T
    setElement(index: usize, value: T)
    ensureCapacity(capacity: usize)

    get capacity: usize
}

public class ArrayBackedStorage<T: Default> {
    array: [T]

    public static empty<T: Default>(): ArrayBackedStorage<T> {
        return new ArrayBackedStorage<T> {
            array = new T[default(T); 0]
        }
    }
}

implement <T: Default> PositionalStorage<T> for ArrayBackedStorage<T> {
    getElement(index: usize): T => this.array[index]

    setElement(index: usize, value: T) {
        this.array[index] = value
    }

    ensureCapacity(capacity: usize) {
        if capacity > this.array.length {
            let newCapacity = capacity
            // TODO implement a load factor
            // let newCapacity = this.array.length * 2 + 1
            // while newCapacity < capacity {
            //     newCapacity *= 2
            // }

            let newBuffer = new T[default(T); newCapacity]
            array.copy<T>(this.array, 0, newBuffer, 0, this.array.length)
            this.array = newBuffer
        }
    }

    public get capacity: usize => this.array.length
}

public class ArrayIterator<T> {
    arr: [T]
    idx: usize

    static create<T>(arr: [T]): ArrayIterator<T> {
        return new ArrayIterator<T> {
            arr
            idx = 0
        }
    }
}

implement <T> Iterator<T> for ArrayIterator<T> {
    get next: ?T {
        if this.idx >= this.arr.length {
            return null
        }

        let element = this.arr[this.idx]
        this.idx += 1
        return element
    }
}
