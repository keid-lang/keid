namespace core::string

import (
    core::mem
    core::object
    core::ops
)

public class String {
    chars: [char]

    public get length: usize => this.chars.length

    static unsafe getCStrLength(cstr: Pointer<uint8>): usize {
        let currentPtr = cstr
        let size: usize = 0
        loop {
            let nextByte = deref currentPtr
            if nextByte == 0 {
                return size
            }
            size += 1
            currentPtr = currentPtr.offset(1)
        }
    }

    public static unsafe fromCStr(cstr: Pointer<uint8>): string {
        let len = string.getCStrLength(cstr)
        if len == 0 {
            return ""
        }
        return string.fromUtf8(array.copyFromPtr<uint8>(cstr, len))
    }

    /// Note that any changes to the new underlying array will be reflected in the string's value.
    public static fromUtf8(bytes: [uint8]): string {
        let chars = new char[default(char); bytes.length]
        for i in range.create(0, bytes.length) {
            chars[i] = bytes[i] as char
        }

        return new string {
            chars
        }
    }

    /// Returns the string as a UTF-8 encoded byte slice.
    /// No null terminator is added.
    public toUtf8(): [uint8] {
        if this.chars.length == 0 {
            return new uint8[]
        }

        let utf8 = new uint8[0; this.chars.length]
        for i in range.create(0, this.chars.length) {
            utf8[i] = this.chars[i] as uint8
        }
        return utf8
    }

    /// Returns an array containing the characters in the string as NUL-terminated and UTF-8 encoded.
    public toNullTerminated(): [uint8] {
        if this.chars.length == 0 {
            return new uint8[0] // return just a null terminator
        }

        // the last char stays zero, making it null terminated
        let terminated = new uint8[0; this.chars.length + 1]
        for i in range.create(0, this.chars.length) {
            terminated[i] = this.chars[i] as uint8
        }
        return terminated
    }
}

implement ToString for String {
    toString(): string => this
}

implement Equals<String> for String {
    equals(other: string): bool {
        if this.length != other.length {
            return false
        }

        for i in range.create(0, this.length) {
            if this.chars[i] != other.chars[i] {
                return false
            }
        }

        return true
    }
}

implement Add<String> for String {
    type Output = string

    add(other: string): Output {
        let sb = StringBuilder.withCapacity(this.length + other.length)
        sb.append(this)
        sb.append(other)
        return sb.toString()
    }
}

implement Default for String {
    static default(): object => ""
}
